// Code generated by protoc-gen-zig
///! package mmc.info
const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const ManagedString = protobuf.ManagedString;
const fd = protobuf.fd;
const ManagedStruct = protobuf.ManagedStruct;
const json = protobuf.json;
const UnionDecodingError = protobuf.UnionDecodingError;

pub const Range = struct {
    start_id: u32 = 0,
    end_id: u32 = 0,

    pub const _desc_table = .{
        .start_id = fd(1, .{ .Varint = .Simple }),
        .end_id = fd(2, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const Ids = struct {
    ids: ArrayList(u32),

    pub const _desc_table = .{
        .ids = fd(1, .{ .PackedList = .{ .Varint = .Simple } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const Request = struct {
    body: ?body_union,

    pub const _body_case = enum {
        command,
        system,
    };
    pub const body_union = union(_body_case) {
        command: Request.Command,
        system: Request.System,
        pub const _union_desc = .{
            .command = fd(1, .{ .SubMessage = {} }),
            .system = fd(2, .{ .SubMessage = {} }),
        };
    };

    pub const _desc_table = .{
        .body = fd(null, .{ .OneOf = body_union }),
    };

    pub const Command = struct {
        id: ?u32 = null,

        pub const _desc_table = .{
            .id = fd(1, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub const System = struct {
        line_id: u32 = 0,
        driver: bool = false,
        axis: bool = false,
        carrier: bool = false,
        source: ?source_union,

        pub const _source_case = enum {
            driver_range,
            axis_range,
            carriers,
        };
        pub const source_union = union(_source_case) {
            driver_range: Range,
            axis_range: Range,
            carriers: Ids,
            pub const _union_desc = .{
                .driver_range = fd(5, .{ .SubMessage = {} }),
                .axis_range = fd(6, .{ .SubMessage = {} }),
                .carriers = fd(7, .{ .SubMessage = {} }),
            };
        };

        pub const _desc_table = .{
            .line_id = fd(1, .{ .Varint = .Simple }),
            .driver = fd(2, .{ .Varint = .Simple }),
            .axis = fd(3, .{ .Varint = .Simple }),
            .carrier = fd(4, .{ .Varint = .Simple }),
            .source = fd(null, .{ .OneOf = source_union }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const Response = struct {
    body: ?body_union,

    pub const _body_case = enum {
        commands,
        system,
        request_error,
    };
    pub const body_union = union(_body_case) {
        commands: Response.Commands,
        system: Response.System,
        request_error: Response.RequestErrorKind,
        pub const _union_desc = .{
            .commands = fd(1, .{ .SubMessage = {} }),
            .system = fd(2, .{ .SubMessage = {} }),
            .request_error = fd(3, .{ .Varint = .Simple }),
        };
    };

    pub const _desc_table = .{
        .body = fd(null, .{ .OneOf = body_union }),
    };

    pub const RequestErrorKind = enum(i32) {
        INFO_REQUEST_ERROR_UNSPECIFIED = 0,
        INFO_REQUEST_ERROR_INVALID_LINE = 1,
        INFO_REQUEST_ERROR_INVALID_AXIS = 2,
        INFO_REQUEST_ERROR_INVALID_DRIVER = 3,
        INFO_REQUEST_ERROR_CARRIER_NOT_FOUND = 4,
        INFO_REQUEST_ERROR_CC_LINK_DISCONNECTED = 5,
        INFO_REQUEST_ERROR_MISSING_PARAMETER = 6,
        INFO_REQUEST_ERROR_COMMAND_NOT_FOUND = 7,
        _,
    };

    pub const Commands = struct {
        commands: ArrayList(Response.Commands.Command),

        pub const _desc_table = .{
            .commands = fd(1, .{ .List = .{ .SubMessage = {} } }),
        };

        pub const Command = struct {
            id: u32 = 0,
            status: Response.Commands.Command.Status = @enumFromInt(0),
            error_response: ?Response.Commands.Command.ErrorKind = null,

            pub const _desc_table = .{
                .id = fd(1, .{ .Varint = .Simple }),
                .status = fd(2, .{ .Varint = .Simple }),
                .error_response = fd(3, .{ .Varint = .Simple }),
            };

            pub const Status = enum(i32) {
                STATUS_UNSPECIFIED = 0,
                STATUS_PROGRESSING = 1,
                STATUS_COMPLETED = 2,
                STATUS_FAILED = 3,
                STATUS_QUEUED = 4,
                _,
            };

            pub const ErrorKind = enum(i32) {
                ERROR_KIND_UNSPECIFIED = 0,
                ERROR_KIND_INVALID_COMMAND = 1,
                ERROR_KIND_CARRIER_NOT_FOUND = 2,
                ERROR_KIND_HOMING_FAILED = 3,
                ERROR_KIND_INVALID_PARAMETER = 4,
                ERROR_KIND_INVALID_SYSTEM_STATE = 5,
                ERROR_KIND_CARRIER_ALREADY_EXISTS = 6,
                ERROR_KIND_INVALID_AXIS = 7,
                _,
            };

            pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                return protobuf.pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                return protobuf.pb_decode(@This(), input, allocator);
            }
            pub fn init(allocator: Allocator) @This() {
                return protobuf.pb_init(@This(), allocator);
            }
            pub fn deinit(self: @This()) void {
                return protobuf.pb_deinit(self);
            }
            pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                return protobuf.pb_dupe(@This(), self, allocator);
            }
            pub fn json_decode(
                input: []const u8,
                options: json.ParseOptions,
                allocator: Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.pb_json_decode(@This(), input, options, allocator);
            }
            pub fn json_encode(
                self: @This(),
                options: json.Stringify.Options,
                allocator: Allocator,
            ) ![]const u8 {
                return protobuf.pb_json_encode(self, options, allocator);
            }

            // This method is used by std.json
            // internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: Allocator,
                source: anytype,
                options: json.ParseOptions,
            ) !@This() {
                return protobuf.pb_json_parse(@This(), allocator, source, options);
            }

            // This method is used by std.json
            // internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.pb_jsonStringify(@This(), self, jws);
            }
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub const System = struct {
        line_id: u32 = 0,
        driver_infos: ArrayList(Response.System.Driver.Info),
        driver_errors: ArrayList(Response.System.Driver.Error),
        axis_infos: ArrayList(Response.System.Axis.Info),
        axis_errors: ArrayList(Response.System.Axis.Error),
        carrier_infos: ArrayList(Response.System.Carrier.Info),

        pub const _desc_table = .{
            .line_id = fd(1, .{ .Varint = .Simple }),
            .driver_infos = fd(2, .{ .List = .{ .SubMessage = {} } }),
            .driver_errors = fd(3, .{ .List = .{ .SubMessage = {} } }),
            .axis_infos = fd(4, .{ .List = .{ .SubMessage = {} } }),
            .axis_errors = fd(5, .{ .List = .{ .SubMessage = {} } }),
            .carrier_infos = fd(6, .{ .List = .{ .SubMessage = {} } }),
        };

        pub const Axis = struct {
            pub const _desc_table = .{};

            pub const Info = struct {
                id: u32 = 0,
                motor_enabled: bool = false,
                waiting_pull: bool = false,
                waiting_push: bool = false,
                carrier_id: u32 = 0,
                hall_alarm: ?Response.System.Axis.Info.HallAlarm = null,

                pub const _desc_table = .{
                    .id = fd(1, .{ .Varint = .Simple }),
                    .motor_enabled = fd(2, .{ .Varint = .Simple }),
                    .waiting_pull = fd(3, .{ .Varint = .Simple }),
                    .waiting_push = fd(4, .{ .Varint = .Simple }),
                    .carrier_id = fd(5, .{ .Varint = .Simple }),
                    .hall_alarm = fd(6, .{ .SubMessage = {} }),
                };

                pub const HallAlarm = struct {
                    back: bool = false,
                    front: bool = false,

                    pub const _desc_table = .{
                        .back = fd(1, .{ .Varint = .Simple }),
                        .front = fd(2, .{ .Varint = .Simple }),
                    };

                    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                        return protobuf.pb_encode(self, allocator);
                    }
                    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                        return protobuf.pb_decode(@This(), input, allocator);
                    }
                    pub fn init(allocator: Allocator) @This() {
                        return protobuf.pb_init(@This(), allocator);
                    }
                    pub fn deinit(self: @This()) void {
                        return protobuf.pb_deinit(self);
                    }
                    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                        return protobuf.pb_dupe(@This(), self, allocator);
                    }
                    pub fn json_decode(
                        input: []const u8,
                        options: json.ParseOptions,
                        allocator: Allocator,
                    ) !std.json.Parsed(@This()) {
                        return protobuf.pb_json_decode(@This(), input, options, allocator);
                    }
                    pub fn json_encode(
                        self: @This(),
                        options: json.Stringify.Options,
                        allocator: Allocator,
                    ) ![]const u8 {
                        return protobuf.pb_json_encode(self, options, allocator);
                    }

                    // This method is used by std.json
                    // internally for deserialization. DO NOT RENAME!
                    pub fn jsonParse(
                        allocator: Allocator,
                        source: anytype,
                        options: json.ParseOptions,
                    ) !@This() {
                        return protobuf.pb_json_parse(@This(), allocator, source, options);
                    }

                    // This method is used by std.json
                    // internally for serialization. DO NOT RENAME!
                    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                        return protobuf.pb_jsonStringify(@This(), self, jws);
                    }
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub const Error = struct {
                id: u32 = 0,
                overcurrent: bool = false,

                pub const _desc_table = .{
                    .id = fd(1, .{ .Varint = .Simple }),
                    .overcurrent = fd(2, .{ .Varint = .Simple }),
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                return protobuf.pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                return protobuf.pb_decode(@This(), input, allocator);
            }
            pub fn init(allocator: Allocator) @This() {
                return protobuf.pb_init(@This(), allocator);
            }
            pub fn deinit(self: @This()) void {
                return protobuf.pb_deinit(self);
            }
            pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                return protobuf.pb_dupe(@This(), self, allocator);
            }
            pub fn json_decode(
                input: []const u8,
                options: json.ParseOptions,
                allocator: Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.pb_json_decode(@This(), input, options, allocator);
            }
            pub fn json_encode(
                self: @This(),
                options: json.Stringify.Options,
                allocator: Allocator,
            ) ![]const u8 {
                return protobuf.pb_json_encode(self, options, allocator);
            }

            // This method is used by std.json
            // internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: Allocator,
                source: anytype,
                options: json.ParseOptions,
            ) !@This() {
                return protobuf.pb_json_parse(@This(), allocator, source, options);
            }

            // This method is used by std.json
            // internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.pb_jsonStringify(@This(), self, jws);
            }
        };

        pub const Driver = struct {
            pub const _desc_table = .{};

            pub const Info = struct {
                id: u32 = 0,
                connected: bool = false,
                available: bool = false,
                servo_enabled: bool = false,
                stopped: bool = false,
                paused: bool = false,

                pub const _desc_table = .{
                    .id = fd(1, .{ .Varint = .Simple }),
                    .connected = fd(2, .{ .Varint = .Simple }),
                    .available = fd(3, .{ .Varint = .Simple }),
                    .servo_enabled = fd(4, .{ .Varint = .Simple }),
                    .stopped = fd(5, .{ .Varint = .Simple }),
                    .paused = fd(6, .{ .Varint = .Simple }),
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub const Error = struct {
                id: u32 = 0,
                control_loop_time_exceeded: bool = false,
                inverter_overheat: bool = false,
                power_error: ?Response.System.Driver.Error.PowerError = null,
                communication_error: ?Response.System.Driver.Error.CommError = null,

                pub const _desc_table = .{
                    .id = fd(1, .{ .Varint = .Simple }),
                    .control_loop_time_exceeded = fd(2, .{ .Varint = .Simple }),
                    .inverter_overheat = fd(3, .{ .Varint = .Simple }),
                    .power_error = fd(4, .{ .SubMessage = {} }),
                    .communication_error = fd(5, .{ .SubMessage = {} }),
                };

                pub const CommError = struct {
                    from_prev: bool = false,
                    from_next: bool = false,

                    pub const _desc_table = .{
                        .from_prev = fd(1, .{ .Varint = .Simple }),
                        .from_next = fd(2, .{ .Varint = .Simple }),
                    };

                    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                        return protobuf.pb_encode(self, allocator);
                    }
                    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                        return protobuf.pb_decode(@This(), input, allocator);
                    }
                    pub fn init(allocator: Allocator) @This() {
                        return protobuf.pb_init(@This(), allocator);
                    }
                    pub fn deinit(self: @This()) void {
                        return protobuf.pb_deinit(self);
                    }
                    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                        return protobuf.pb_dupe(@This(), self, allocator);
                    }
                    pub fn json_decode(
                        input: []const u8,
                        options: json.ParseOptions,
                        allocator: Allocator,
                    ) !std.json.Parsed(@This()) {
                        return protobuf.pb_json_decode(@This(), input, options, allocator);
                    }
                    pub fn json_encode(
                        self: @This(),
                        options: json.Stringify.Options,
                        allocator: Allocator,
                    ) ![]const u8 {
                        return protobuf.pb_json_encode(self, options, allocator);
                    }

                    // This method is used by std.json
                    // internally for deserialization. DO NOT RENAME!
                    pub fn jsonParse(
                        allocator: Allocator,
                        source: anytype,
                        options: json.ParseOptions,
                    ) !@This() {
                        return protobuf.pb_json_parse(@This(), allocator, source, options);
                    }

                    // This method is used by std.json
                    // internally for serialization. DO NOT RENAME!
                    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                        return protobuf.pb_jsonStringify(@This(), self, jws);
                    }
                };

                pub const PowerError = struct {
                    overvoltage: bool = false,
                    undervoltage: bool = false,

                    pub const _desc_table = .{
                        .overvoltage = fd(1, .{ .Varint = .Simple }),
                        .undervoltage = fd(2, .{ .Varint = .Simple }),
                    };

                    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                        return protobuf.pb_encode(self, allocator);
                    }
                    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                        return protobuf.pb_decode(@This(), input, allocator);
                    }
                    pub fn init(allocator: Allocator) @This() {
                        return protobuf.pb_init(@This(), allocator);
                    }
                    pub fn deinit(self: @This()) void {
                        return protobuf.pb_deinit(self);
                    }
                    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                        return protobuf.pb_dupe(@This(), self, allocator);
                    }
                    pub fn json_decode(
                        input: []const u8,
                        options: json.ParseOptions,
                        allocator: Allocator,
                    ) !std.json.Parsed(@This()) {
                        return protobuf.pb_json_decode(@This(), input, options, allocator);
                    }
                    pub fn json_encode(
                        self: @This(),
                        options: json.Stringify.Options,
                        allocator: Allocator,
                    ) ![]const u8 {
                        return protobuf.pb_json_encode(self, options, allocator);
                    }

                    // This method is used by std.json
                    // internally for deserialization. DO NOT RENAME!
                    pub fn jsonParse(
                        allocator: Allocator,
                        source: anytype,
                        options: json.ParseOptions,
                    ) !@This() {
                        return protobuf.pb_json_parse(@This(), allocator, source, options);
                    }

                    // This method is used by std.json
                    // internally for serialization. DO NOT RENAME!
                    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                        return protobuf.pb_jsonStringify(@This(), self, jws);
                    }
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                return protobuf.pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                return protobuf.pb_decode(@This(), input, allocator);
            }
            pub fn init(allocator: Allocator) @This() {
                return protobuf.pb_init(@This(), allocator);
            }
            pub fn deinit(self: @This()) void {
                return protobuf.pb_deinit(self);
            }
            pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                return protobuf.pb_dupe(@This(), self, allocator);
            }
            pub fn json_decode(
                input: []const u8,
                options: json.ParseOptions,
                allocator: Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.pb_json_decode(@This(), input, options, allocator);
            }
            pub fn json_encode(
                self: @This(),
                options: json.Stringify.Options,
                allocator: Allocator,
            ) ![]const u8 {
                return protobuf.pb_json_encode(self, options, allocator);
            }

            // This method is used by std.json
            // internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: Allocator,
                source: anytype,
                options: json.ParseOptions,
            ) !@This() {
                return protobuf.pb_json_parse(@This(), allocator, source, options);
            }

            // This method is used by std.json
            // internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.pb_jsonStringify(@This(), self, jws);
            }
        };

        pub const Carrier = struct {
            pub const _desc_table = .{};

            pub const Info = struct {
                id: u32 = 0,
                position: f32 = 0,
                axis: ?Response.System.Carrier.Info.Axis = null,
                cas: ?Response.System.Carrier.Info.Cas = null,
                state: Response.System.Carrier.Info.State = @enumFromInt(0),

                pub const _desc_table = .{
                    .id = fd(1, .{ .Varint = .Simple }),
                    .position = fd(2, .{ .FixedInt = .I32 }),
                    .axis = fd(3, .{ .SubMessage = {} }),
                    .cas = fd(4, .{ .SubMessage = {} }),
                    .state = fd(5, .{ .Varint = .Simple }),
                };

                pub const State = enum(i32) {
                    CARRIER_STATE_NONE = 0,
                    CARRIER_STATE_CALIBRATING = 1,
                    CARRIER_STATE_CALIBRATE_COMPLETED = 2,
                    CARRIER_STATE_MOVING = 3,
                    CARRIER_STATE_MOVE_COMPLETED = 4,
                    CARRIER_STATE_ISOLATING = 5,
                    CARRIER_STATE_ISOLATE_COMPLETED = 6,
                    CARRIER_STATE_PUSHING = 7,
                    CARRIER_STATE_PUSH_COMPLETED = 8,
                    CARRIER_STATE_PULLING = 9,
                    CARRIER_STATE_PULL_COMPLETED = 10,
                    CARRIER_STATE_OVERCURRENT = 11,
                    _,
                };

                pub const Axis = struct {
                    main: u32 = 0,
                    auxiliary: ?u32 = null,

                    pub const _desc_table = .{
                        .main = fd(1, .{ .Varint = .Simple }),
                        .auxiliary = fd(2, .{ .Varint = .Simple }),
                    };

                    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                        return protobuf.pb_encode(self, allocator);
                    }
                    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                        return protobuf.pb_decode(@This(), input, allocator);
                    }
                    pub fn init(allocator: Allocator) @This() {
                        return protobuf.pb_init(@This(), allocator);
                    }
                    pub fn deinit(self: @This()) void {
                        return protobuf.pb_deinit(self);
                    }
                    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                        return protobuf.pb_dupe(@This(), self, allocator);
                    }
                    pub fn json_decode(
                        input: []const u8,
                        options: json.ParseOptions,
                        allocator: Allocator,
                    ) !std.json.Parsed(@This()) {
                        return protobuf.pb_json_decode(@This(), input, options, allocator);
                    }
                    pub fn json_encode(
                        self: @This(),
                        options: json.Stringify.Options,
                        allocator: Allocator,
                    ) ![]const u8 {
                        return protobuf.pb_json_encode(self, options, allocator);
                    }

                    // This method is used by std.json
                    // internally for deserialization. DO NOT RENAME!
                    pub fn jsonParse(
                        allocator: Allocator,
                        source: anytype,
                        options: json.ParseOptions,
                    ) !@This() {
                        return protobuf.pb_json_parse(@This(), allocator, source, options);
                    }

                    // This method is used by std.json
                    // internally for serialization. DO NOT RENAME!
                    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                        return protobuf.pb_jsonStringify(@This(), self, jws);
                    }
                };

                pub const Cas = struct {
                    enabled: bool = false,
                    triggered: bool = false,

                    pub const _desc_table = .{
                        .enabled = fd(1, .{ .Varint = .Simple }),
                        .triggered = fd(2, .{ .Varint = .Simple }),
                    };

                    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                        return protobuf.pb_encode(self, allocator);
                    }
                    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                        return protobuf.pb_decode(@This(), input, allocator);
                    }
                    pub fn init(allocator: Allocator) @This() {
                        return protobuf.pb_init(@This(), allocator);
                    }
                    pub fn deinit(self: @This()) void {
                        return protobuf.pb_deinit(self);
                    }
                    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                        return protobuf.pb_dupe(@This(), self, allocator);
                    }
                    pub fn json_decode(
                        input: []const u8,
                        options: json.ParseOptions,
                        allocator: Allocator,
                    ) !std.json.Parsed(@This()) {
                        return protobuf.pb_json_decode(@This(), input, options, allocator);
                    }
                    pub fn json_encode(
                        self: @This(),
                        options: json.Stringify.Options,
                        allocator: Allocator,
                    ) ![]const u8 {
                        return protobuf.pb_json_encode(self, options, allocator);
                    }

                    // This method is used by std.json
                    // internally for deserialization. DO NOT RENAME!
                    pub fn jsonParse(
                        allocator: Allocator,
                        source: anytype,
                        options: json.ParseOptions,
                    ) !@This() {
                        return protobuf.pb_json_parse(@This(), allocator, source, options);
                    }

                    // This method is used by std.json
                    // internally for serialization. DO NOT RENAME!
                    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                        return protobuf.pb_jsonStringify(@This(), self, jws);
                    }
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                return protobuf.pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                return protobuf.pb_decode(@This(), input, allocator);
            }
            pub fn init(allocator: Allocator) @This() {
                return protobuf.pb_init(@This(), allocator);
            }
            pub fn deinit(self: @This()) void {
                return protobuf.pb_deinit(self);
            }
            pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                return protobuf.pb_dupe(@This(), self, allocator);
            }
            pub fn json_decode(
                input: []const u8,
                options: json.ParseOptions,
                allocator: Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.pb_json_decode(@This(), input, options, allocator);
            }
            pub fn json_encode(
                self: @This(),
                options: json.Stringify.Options,
                allocator: Allocator,
            ) ![]const u8 {
                return protobuf.pb_json_encode(self, options, allocator);
            }

            // This method is used by std.json
            // internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: Allocator,
                source: anytype,
                options: json.ParseOptions,
            ) !@This() {
                return protobuf.pb_json_parse(@This(), allocator, source, options);
            }

            // This method is used by std.json
            // internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.pb_jsonStringify(@This(), self, jws);
            }
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

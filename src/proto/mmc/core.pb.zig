// Code generated by protoc-gen-zig
///! package mmc.core
const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const ManagedString = protobuf.ManagedString;
const fd = protobuf.fd;
const ManagedStruct = protobuf.ManagedStruct;
const json = protobuf.json;
const UnionDecodingError = protobuf.UnionDecodingError;

pub const Request = struct {
    kind: Request.Kind = @enumFromInt(0),

    pub const _desc_table = .{
        .kind = fd(1, .{ .Varint = .Simple }),
    };

    pub const Kind = enum(i32) {
        CORE_REQUEST_KIND_UNSPECIFIED = 0,
        CORE_REQUEST_KIND_API_VERSION = 1,
        CORE_REQUEST_KIND_SERVER_INFO = 2,
        CORE_REQUEST_KIND_LINE_CONFIG = 3,
        _,
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const Response = struct {
    body: ?body_union,

    pub const _body_case = enum {
        server,
        api_version,
        line_config,
        request_error,
    };
    pub const body_union = union(_body_case) {
        server: Response.Server,
        api_version: Response.SemanticVersion,
        line_config: Response.LineConfig,
        request_error: Response.RequestErrorKind,
        pub const _union_desc = .{
            .server = fd(1, .{ .SubMessage = {} }),
            .api_version = fd(2, .{ .SubMessage = {} }),
            .line_config = fd(3, .{ .SubMessage = {} }),
            .request_error = fd(4, .{ .Varint = .Simple }),
        };
    };

    pub const _desc_table = .{
        .body = fd(null, .{ .OneOf = body_union }),
    };

    pub const RequestErrorKind = enum(i32) {
        CORE_REQUEST_ERROR_UNSPECIFIED = 0,
        CORE_REQUEST_ERROR_REQUEST_UNKNOWN = 1,
        _,
    };

    pub const LineConfig = struct {
        lines: ArrayList(Response.LineConfig.Line),

        pub const _desc_table = .{
            .lines = fd(1, .{ .List = .{ .SubMessage = {} } }),
        };

        pub const Line = struct {
            axes: u32 = 0,
            name: ManagedString = .Empty,
            length: ?Response.LineConfig.Line.Length = null,

            pub const _desc_table = .{
                .axes = fd(1, .{ .Varint = .Simple }),
                .name = fd(2, .String),
                .length = fd(3, .{ .SubMessage = {} }),
            };

            pub const Length = struct {
                axis: f32 = 0,
                carrier: f32 = 0,

                pub const _desc_table = .{
                    .axis = fd(1, .{ .FixedInt = .I32 }),
                    .carrier = fd(2, .{ .FixedInt = .I32 }),
                };

                pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                    return protobuf.pb_encode(self, allocator);
                }
                pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                    return protobuf.pb_decode(@This(), input, allocator);
                }
                pub fn init(allocator: Allocator) @This() {
                    return protobuf.pb_init(@This(), allocator);
                }
                pub fn deinit(self: @This()) void {
                    return protobuf.pb_deinit(self);
                }
                pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                    return protobuf.pb_dupe(@This(), self, allocator);
                }
                pub fn json_decode(
                    input: []const u8,
                    options: json.ParseOptions,
                    allocator: Allocator,
                ) !std.json.Parsed(@This()) {
                    return protobuf.pb_json_decode(@This(), input, options, allocator);
                }
                pub fn json_encode(
                    self: @This(),
                    options: json.Stringify.Options,
                    allocator: Allocator,
                ) ![]const u8 {
                    return protobuf.pb_json_encode(self, options, allocator);
                }

                // This method is used by std.json
                // internally for deserialization. DO NOT RENAME!
                pub fn jsonParse(
                    allocator: Allocator,
                    source: anytype,
                    options: json.ParseOptions,
                ) !@This() {
                    return protobuf.pb_json_parse(@This(), allocator, source, options);
                }

                // This method is used by std.json
                // internally for serialization. DO NOT RENAME!
                pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                    return protobuf.pb_jsonStringify(@This(), self, jws);
                }
            };

            pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
                return protobuf.pb_encode(self, allocator);
            }
            pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
                return protobuf.pb_decode(@This(), input, allocator);
            }
            pub fn init(allocator: Allocator) @This() {
                return protobuf.pb_init(@This(), allocator);
            }
            pub fn deinit(self: @This()) void {
                return protobuf.pb_deinit(self);
            }
            pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
                return protobuf.pb_dupe(@This(), self, allocator);
            }
            pub fn json_decode(
                input: []const u8,
                options: json.ParseOptions,
                allocator: Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.pb_json_decode(@This(), input, options, allocator);
            }
            pub fn json_encode(
                self: @This(),
                options: json.Stringify.Options,
                allocator: Allocator,
            ) ![]const u8 {
                return protobuf.pb_json_encode(self, options, allocator);
            }

            // This method is used by std.json
            // internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: Allocator,
                source: anytype,
                options: json.ParseOptions,
            ) !@This() {
                return protobuf.pb_json_parse(@This(), allocator, source, options);
            }

            // This method is used by std.json
            // internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.pb_jsonStringify(@This(), self, jws);
            }
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub const SemanticVersion = struct {
        major: u32 = 0,
        minor: u32 = 0,
        patch: u32 = 0,

        pub const _desc_table = .{
            .major = fd(1, .{ .Varint = .Simple }),
            .minor = fd(2, .{ .Varint = .Simple }),
            .patch = fd(3, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub const Server = struct {
        version: ?Response.SemanticVersion = null,
        name: ManagedString = .Empty,

        pub const _desc_table = .{
            .version = fd(1, .{ .SubMessage = {} }),
            .name = fd(2, .String),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

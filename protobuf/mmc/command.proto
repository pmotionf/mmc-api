syntax = "proto3";
package mmc.command;

import "mmc/control.proto";
import "range.proto";

// Command API: List of commands to operate the PMF's motion system.
//
// When a command is sent to the server, it will be queued for execution.
// Command execution status can be polled through the Info API. The status
// remains stored in a limited history buffer, and should be cleared with
// `remove_command` after completion.
message Request {
  oneof body {
    // Calibrate a line. This command only needs to be run once after hardware
    // setup; calibrated values will remain stored in drivers even after a
    // power cycle.
    Calibrate calibrate = 1;
    // Set the zero position of the specified line. This command can be run
    // optionally after calibration, upon which all drivers will store the set
    // zero position of the line. The set zero position will remain unchanged
    // even after a power cycle.
    SetZero set_zero = 2;
    // Initialize a carrier. Carriers must be initialized before they can be
    // moved. Initialization is required after every power cycle.
    Initialize initialize = 3;
    // Initialize all carriers of the specified line(s). If no lines are
    // specified, initialize all carriers across all lines in the track.
    AutoInitialize auto_initialize = 4;
    // Deinitialize a carrier. This removes all carrier information, such as
    // recognized position and carrier ID.
    Deinitialize deinitialize = 5;
    // Move an initialized carrier to the desired position.
    Move move = 6;
    // Pull and initialize a new carrier into a line.
    Pull pull = 7;
    // Push an initialized carrier to the specified direction.
    Push push = 8;
    // Stop waiting to pull a new carrier at an axis.
    StopPull stop_pull = 9;
    // Stop waiting to push an initialized carrier at an axis.
    StopPush stop_push = 10;
    // Release the motor control of a carrier.
    Release release = 11;
    // Clear all errors within the specified driver range.
    ClearErrors clear_errors = 12;
    // Cancel a running command or remove its status history.
    RemoveCommand remove_command = 13;
    // Activate emergency stop for all drivers in line(s). Emergency stop will
    // cause all carriers to deccelerate to rest, then reset all carriers'
    // movement commands.
    Stop stop = 14;
    // Activate pause for all drivers in line(s). Pause will cause all
    // carriers to deccelerate to rest. On resume, the carriers will continue
    // their previously assigned movement commands.
    Pause pause = 15;
    // Deactivate emergency stop and pause for all drivers in line(s).
    Resume resume = 16;
    // Change an existing carrier ID to a new unique carrier ID.
    SetCarrierId set_carrier_id = 17;
  }

  // Release the control imposed by the motor to the carrier. If a target is
  // specified, the motor which is located on the target release the control.
  // Otherwise, all carriers on the provided line will be released from control.
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Release {
    // Line ID.
    uint32 line = 1;
    oneof target {
      // Carrier ID.
      uint32 carrier = 2;
      // Axis ID range.
      Range axes = 3;
      // Driver ID range.
      Range drivers = 4;
    }
  }

  // Stop pulling a carrier to the specified axis. If no axis is provided,
  // then all pending carrier pulls on the line will be stopped.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message StopPull {
    // Line ID.
    uint32 line = 1;
    // Axis ID range.
    optional Range axes = 2;
  }

  // Stop pushing a carrier from the specified axis. If no axis is provided,
  // then all pending carrier pushes on the line will be stopped.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message StopPush {
    // Line ID.
    uint32 line = 1;
    // Axis ID range.
    optional Range axes = 2;
  }

  // Clear all error information on the driver. If a target is specified,
  // clear error information of drivers which is located on the target. If not,
  // clear error information on every driver of the specified line ID.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message ClearErrors {
    // Line ID.
    uint32 line = 1;
    oneof target {
      // Driver ID range.
      Range drivers = 2;
      // Axis ID range.
      Range axes = 3;
      // Carrier ID.
      uint32 carrier = 4;
    }
  }

  // Clear carrier information located on the axis. If a target is specified,
  // clear information of carriers which is located on the target. If not,
  // clear all carrier information of the specified line ID
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Deinitialize {
    // Line ID.
    uint32 line = 1;
    oneof target {
      // Axis ID range.
      Range axes = 2;
      // Driver ID range.
      Range drivers = 3;
      // Carrier ID.
      uint32 carrier = 4;
    }
  }

  // Calibrate a line by positioning an unitiliazed carrier on the first axis
  // of the line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Calibrate {
    // Line ID.
    uint32 line = 1;
  }

  // Set a zero position of a line by positioning an initialized carrier on
  // the first axis of the line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message SetZero {
    // Line ID.
    uint32 line = 1;
  }

  // Automatically initialize carriers on every specified lines.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message AutoInitialize {
    message Line {
      // Line ID.
      uint32 line = 1;
      // If `velocity_mode` field is set to `normal`, the integer range is
      // 1-100 representing 0.1-10 m/s.
      // If `velocity_mode` field is set to `low`, the integer range is
      // 1-1000 representing 0.1-100 mm/s.
      optional uint32 velocity = 2;
      // Fixed point integer from 1-245, representing 0.1-24.5 m/s^2.
      // (default 6 m/s^2)
      optional uint32 acceleration = 3;
      // Specify the unit of the `velocity` value.
      VelocityMode velocity_mode = 4;
    }
    repeated Line lines = 1;
  }

  // Move a carrier to the desired position.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Move {
    // Line ID.
    uint32 line = 1;
    // Carrier ID.
    uint32 carrier = 2;
    // If `velocity_mode` field is set to `normal`, the integer range is 1-100
    // representing 0.1-10 m/s.
    // If `velocity_mode` field is set to `low`, the integer range is 1-1000
    // representing 0.1-100 mm/s.
    uint32 velocity = 3;
    // Fixed point integer from 1-245, representing 0.1-24.5 m/s^2.
    uint32 acceleration = 4;
    // [Required] Specify carrier target movement.
    oneof target {
      // Move carrier to the center of the axis.
      uint32 axis = 5;
      // Move carrier to relative location to the zero-point of the line,
      // which is set by default at the center of the line's first axis after
      // calibration, but can also be set with the `SetZero` command.
      float location = 6;
      // Move carrier to relative distance to current carrier position. Negative
      // distance moves the carrier backwards.
      float distance = 7;
    }
    // Control method for moving carrier.
    mmc.Control control = 8;
    // Disable the carrier's collision avoidance system (CAS).
    bool disable_cas = 9;
    // Specify the unit of the `velocity` value.
    VelocityMode velocity_mode = 10;
  }

  // Push an initialized carrier to the specified direction.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Push {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // Direction of carrier movement.
    Direction direction = 3;
    // If `velocity_mode` field is set to `normal`, the integer range is 1-100
    // representing 0.1-10 m/s.
    // If `velocity_mode` field is set to `low`, the integer range is 1-1000
    // representing 0.1-100 mm/s.
    uint32 velocity = 4;
    // Fixed point integer from 1-245, representing 0.1-24.5 m/s^2.
    uint32 acceleration = 5;
    // Carrier ID. If provided, wait for the specified carrier at the axis and
    // push it once the carrier arrives.
    optional uint32 carrier = 6;
    // Specify the unit of the `velocity` value.
    VelocityMode velocity_mode = 7;
  }

  // Pull and initialize a new carrier into a line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Pull {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // ID for the incoming carrier.
    uint32 carrier = 3;
    // The direction from which the incoming carrier is moving.
    Direction direction = 4;
    // Fixed point integer.
    // If `velocity_mode` field is set to `normal`, the integer range is 1-100
    // representing 0.1-10 m/s.
    // If `velocity_mode` field is set to `low`, the integer range is 1-1000
    // representing 0.1-100 mm/s.
    uint32 velocity = 5;
    // Fixed point integer from 1-245, representing 0.1-24.5 m/s^2.
    uint32 acceleration = 6;
    // Smoothly transition to carrier movement after pull completion.
    optional Transition transition = 7;
    // Specify the unit of the `velocity` value.
    VelocityMode velocity_mode = 8;

    message Transition {
      // Control method for moving carrier.
      mmc.Control control = 1;
      // Disabling the carrier's collision avoidance system (CAS).
      bool disable_cas = 2;
      oneof target {
        // Move carrier to the center of the axis.
        uint32 axis = 3;
        // Move carrier to relative location to the zero-point of the line,
        // which is set by default at the center of the line's first axis after
        // calibration, but can also be set with the `SetZero` command.
        float location = 4;
        // Move carrier to relative distance to current carrier position.
        // Negative distance moves the carrier backwards.
        float distance = 5;
      }
    }
  }

  // Initialize a carrier.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Initialize {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // ID for the new carrier.
    uint32 carrier = 3;
    // Initialization direction for the new carrier.
    Direction direction = 4;
    // Linked axis direction from the specified axis.
    optional Direction link_axis = 5;
  }

  // Remove a command on the server if the command ID is specified. If no
  // command ID is specified, remove any commands received by the server. If
  // the commands are still progressing, cancel the command execution.
  //
  // Expected response: `mmc.Response.body.command.body.removed_id` (uint32).
  message RemoveCommand {
    // Command ID.
    optional uint32 command = 1;
  }

  // Send an emergency stop command to stop any operation in PMF LMS. This
  // command also removes all queued commands in the server.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Stop {
    // Line ID. If provided, stop operations only on the specified lines and
    // remove all commands that targeting those lines.
    repeated uint32 lines = 1;
  }

  // Pause any operation in PMF LMS. Any queued commands in the server will be
  // continued once the resume command is given.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Pause {
    // Line ID. If provided, pause operations only on the specified lines.
    repeated uint32 lines = 1;
  }

  // Resume lines that have been stopped or paused. If the line is not paused
  // or emergency stopped, this command will succeed without any effect.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Resume {
    // Line ID. If provided, resume operations only to those specified lines.
    repeated uint32 lines = 1;
  }

  // Change the carrier ID of an existing initialized carrier. If the new
  // carrier ID already exists on the line, returns INVALID_CARRIER.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message SetCarrierId {
    // Line ID.
    uint32 line = 1;
    // Target existing initialized carrier ID.
    uint32 carrier = 2;
    // New desired carrier ID (unique in line).
    uint32 new_carrier = 3;
  }

  enum Direction {
    DIRECTION_UNSPECIFIED = 0;
    DIRECTION_BACKWARD = 1;
    DIRECTION_FORWARD = 2;
  }

  enum VelocityMode {
    // Representing 0.1-10 m/s.
    VELOCITY_MODE_NORMAL = 0;
    // Representing 0.1-100 mm/s.
    VELOCITY_MODE_LOW = 1;
  }

  enum Error {
    COMMAND_REQUEST_ERROR_UNSPECIFIED = 0;
    // Attempted to use line ID outside of the configured lines.
    COMMAND_REQUEST_ERROR_INVALID_LINE = 1;
    // Attempted to use axis ID outside of the configured axes of the line.
    COMMAND_REQUEST_ERROR_INVALID_AXIS = 2;
    // Attempted to use driver ID outside of the configured drivers of the line.
    COMMAND_REQUEST_ERROR_INVALID_DRIVER = 3;
    // Attempted to use acceleration value outside of 1-245.
    COMMAND_REQUEST_ERROR_INVALID_ACCELERATION = 4;
    // Attempted to use velocity value outside of 1-60.
    COMMAND_REQUEST_ERROR_INVALID_VELOCITY = 5;
    // Using invalid direction for the command.
    COMMAND_REQUEST_ERROR_INVALID_DIRECTION = 6;
    // Deprecated. Check `COMMAND_ERROR_INVALID_CARRIER_TARGET` on
    // `Info.Response.Command.Error`.
    COMMAND_REQUEST_ERROR_INVALID_LOCATION = 7 [deprecated = true];
    // Deprecated. Check `COMMAND_ERROR_INVALID_CARRIER_TARGET` on
    // `Info.Response.Command.Error`.
    COMMAND_REQUEST_ERROR_INVALID_DISTANCE = 8 [deprecated = true];
    // Attempted to send a command to carrier outside of 1-2048.
    COMMAND_REQUEST_ERROR_INVALID_CARRIER = 9;
    // A command missing the required parameter.
    COMMAND_REQUEST_ERROR_MISSING_PARAMETER = 10;
    // Attempted to remove or cancel a non-existing command.
    COMMAND_REQUEST_ERROR_COMMAND_NOT_FOUND = 11;
    // Attempted to send command to uninitialized carrier.
    COMMAND_REQUEST_ERROR_CARRIER_NOT_FOUND = 12;
    // Deprecated. Check `COMMAND_ERROR_DRIVER_DISCONNECTED` on
    // `Info.Response.Command.Error`.
    COMMAND_REQUEST_ERROR_CC_LINK_DISCONNECTED = 13 [deprecated = true];
    // Server unable to receive new command caused by out of memory.
    // Try `Command.Request.remove_command` to free the memory.
    COMMAND_REQUEST_ERROR_OUT_OF_MEMORY = 14;
    // Attempted to run more than 8 auto initialize instance.
    COMMAND_REQUEST_ERROR_MAXIMUM_AUTO_INITIALIZE_EXCEEDED = 15;
    // Attempted to assign a new carrier with an ID that is already used by
    // other carrier on the same line
    COMMAND_REQUEST_ERROR_CONFLICTING_CARRIER_ID = 16;
  }
}

// Response description to the command API.
message Response {
  oneof body {
    // Assigned ID for newly sent command.
    uint32 id = 1;
    // ID of cleared existing command.
    uint32 removed_id = 3;
    // Error during command's execution.
    Request.Error request_error = 2;
  }
}

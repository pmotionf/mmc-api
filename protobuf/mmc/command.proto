syntax = "proto3";
package mmc.command;

import "mmc/control.proto";
import "range.proto";

// Command API: List of commands to operate the PMF's motion system.
//
// When a command is sent to the server, it will be queued for execution.
// Command execution status can be polled through the Info API. The status
// remains stored in a limited history buffer, and should be cleared with
// `remove_command` after completion.
message Request {
  oneof body {
    // Calibrate a line.
    Calibrate calibrate = 1;
    // Set the zero position of the specified line.
    SetZero set_zero = 2;
    // Initialize a carrier.
    Initialize initialize = 3;
    // Initialize all carriers of the specified line(s).
    AutoInitialize auto_initialize = 4;
    // Deinitialize a carrier.
    Deinitialize deinitialize = 5;
    // Move an initialized carrier to the desired position.
    Move move = 6;
    // Pull and initialize a new carrier into a line.
    Pull pull = 7;
    // Push an initialized carrier to the specified direction.
    Push push = 8;
    // Stop waiting to pull a new carrier at an axis.
    StopPull stop_pull = 9;
    // Stop waiting to push an initialized carrier at an axis.
    StopPush stop_push = 10;
    // Release the motor control of a carrier.
    Release release = 11;
    // Clear error information.
    ClearErrors clear_errors = 12;
    // Cancel a running command or remove its status history.
    RemoveCommand remove_command = 13;
    // Activate emergency stop for all drivers in line(s).
    Stop stop = 14;
    // Activate pause for all drivers in line(s).
    Pause pause = 15;
    // Deactivate emergency stop and pause for all drivers in line(s).
    Resume resume = 16;
    // Set the carrier ID to a new one.
    SetCarrierID set_carrier_id = 17;
  }

  // Release the control imposed by the motor to the carrier. If a carrier is
  // specified, the motor which control the specified carrier release the
  // control. Otherwise, all carriers on the provided line will be released
  // from control.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Release {
    // Line ID.
    uint32 line = 1;
    // Carrier ID.
    optional uint32 carrier = 2;
  }

  // Stop pulling a carrier to the specified axis. If no axis is provided,
  // then all pending carrier pulls on the line will be stopped.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message StopPull {
    // Line ID.
    uint32 line = 1;
    // Axis ID range.
    optional Range axes = 2;
  }

  // Stop pushing a carrier from the specified axis. If no axis is provided,
  // then all pending carrier pushes on the line will be stopped.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message StopPush {
    // Line ID.
    uint32 line = 1;
    // Axis ID range.
    optional Range axes = 2;
  }

  // Clear all error information on the driver, if specified. If not, clear
  // error information on every driver of the specified line ID.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message ClearErrors {
    // Line ID.
    uint32 line = 1;
    // Driver ID range.
    optional Range drivers = 2;
  }

  // Clear carrier information located on the axis, if specified. If not,
  // clear all carrier information of the specified line ID
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Deinitialize {
    // Line ID.
    uint32 line = 1;
    // Axis ID range.
    optional Range axes = 2;
  }

  // Calibrate a line by positioning an unitiliazed carrier on the first axis
  // of the line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Calibrate {
    // Line ID.
    uint32 line = 1;
  }

  // Set a zero position of a line by positioning an initialized carrier on
  // the first axis of the line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message SetZero {
    // Line ID.
    uint32 line = 1;
  }

  // Automatically initialize carriers on every specified lines.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message AutoInitialize {
    message Line {
      // Line ID.
      uint32 line = 1;
      // Fixed point integer from 0-60, representing 0.0-6.0 m/s.
      // (default 1 m/s)
      optional uint32 velocity = 2;
      // Fixed point integer from 0-245, representing 0.0-24.5 m/s^2.
      // (default 6 m/s^2)
      optional uint32 acceleration = 3;
    }
    repeated Line lines = 1;
  }

  // Move a carrier to the desired position.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Move {
    // Line ID.
    uint32 line = 1;
    // Carrier ID.
    uint32 carrier = 2;
    // Fixed point integer from 0-60, representing 0.0-6.0 m/s.
    uint32 velocity = 3;
    // Fixed point integer from 0-245, representing 0.0-24.5 m/s^2.
    uint32 acceleration = 4;
    oneof target {
      // Move carrier to the center of the axis.
      uint32 axis = 5;
      // Move carrier to relative location to the zero-point of the line,
      // which is set by default at the center of the line's first axis after
      // calibration, but can also be set with the `SetZero` command.
      float location = 6;
      // Move carrier to relative distance to current carrier position. Negative
      // distance moves the carrier backwards.
      float distance = 7;
    }
    // Control method for moving carrier.
    mmc.Control control = 8;
    // Disable the carrier's collision avoidance system (CAS).
    bool disable_cas = 9;
  }

  // Push an initialized carrier to the specified direction.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Push {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // Direction of carrier movement.
    Direction direction = 3;
    // Fixed point integer from 0-60, representing 0.0-6.0 m/s.
    uint32 velocity = 4;
    // Fixed point integer from 0-245, representing 0.0-24.5 m/s^2.
    uint32 acceleration = 5;
    // Carrier ID. If provided, wait for the specified carrier at the axis and
    // push it once the carrier arrives.
    optional uint32 carrier = 6;
  }

  // Pull and initialize a new carrier into a line.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Pull {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // ID for the incoming carrier.
    uint32 carrier = 3;
    // The direction from which the incoming carrier is moving.
    Direction direction = 4;
    // Fixed point integer from 0-60, representing 0.0-6.0 m/s.
    uint32 velocity = 5;
    // Fixed point integer from 0-245, representing 0.0-24.5 m/s^2.
    uint32 acceleration = 6;
    // Smoothly transition to carrier movement after pull completion.
    optional Transition transition = 7;

    message Transition {
      // Control method for moving carrier.
      mmc.Control control = 1;
      // Disabling the carrier's collision avoidance system (CAS).
      bool disable_cas = 2;
      oneof target {
        // Move carrier to the center of the axis.
        uint32 axis = 3;
        // Move carrier to relative location to the zero-point of the line,
        // which is set by default at the center of the line's first axis after
        // calibration, but can also be set with the `SetZero` command.
        float location = 4;
        // Move carrier to relative distance to current carrier position.
        // Negative distance moves the carrier backwards.
        float distance = 5;
      }
    }
  }

  // Initialize a carrier.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Initialize {
    // Line ID.
    uint32 line = 1;
    // Axis ID.
    uint32 axis = 2;
    // ID for the new carrier.
    uint32 carrier = 3;
    // Initialization direction for the new carrier.
    Direction direction = 4;
    // Linked axis direction from the specified axis.
    optional Direction link_axis = 5;
  }

  // Remove a command on the server if the command ID is specified. If no
  // command ID is specified, remove any commands received by the server. If
  // the commands are still progressing, cancel the command execution.
  //
  // Expected response: `mmc.Response.body.command.body.removed_id` (uint32).
  message RemoveCommand {
    // Command ID.
    optional uint32 command = 1;
  }

  // Send an emergency stop command to stop any operation in PMF LMS. This
  // command also removes all queued commands in the server.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Stop {
    // Line ID. If provided, stop operations only on the specified lines and
    // remove all commands that targeting those lines.
    repeated uint32 lines = 1;
  }

  // Pause any operation in PMF LMS. Any queued commands in the server will be
  // continued once the resume command is given.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Pause {
    // Line ID. If provided, pause operations only on the specified lines.
    repeated uint32 lines = 1;
  }

  // Resume lines that have been stopped or paused. If the line is not paused
  // or emergency stopped, this command will succeed without any effect.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message Resume {
    // Line ID. If provided, resume operations only to those specified lines.
    repeated uint32 lines = 1;
  }

  // Change the carrier ID of the initialized carrier on the line. If the
  // new carrier ID already exists on the line, return INVALID_CARRIER.
  //
  // Expected response: `mmc.Response.body.command.body.id` (uint32).
  message SetCarrierID {
    // Line ID.
    uint32 line = 1;
    // The carrier in which the ID to be changed.
    uint32 carrier = 2;
    // The new carrier ID.
    uint32 new_carrier_id = 3;
  }

  enum Direction {
    DIRECTION_UNSPECIFIED = 0;
    DIRECTION_BACKWARD = 1;
    DIRECTION_FORWARD = 2;
  }

  enum Error {
    COMMAND_REQUEST_ERROR_UNSPECIFIED = 0;
    // Attempted to use line ID outside of the configured lines.
    COMMAND_REQUEST_ERROR_INVALID_LINE = 1;
    // Attempted to use axis ID outside of the configured axes of the line.
    COMMAND_REQUEST_ERROR_INVALID_AXIS = 2;
    // Attempted to use driver ID outside of the configured drivers of the line.
    COMMAND_REQUEST_ERROR_INVALID_DRIVER = 3;
    // Attempted to use acceleration value outside of 0-245.
    COMMAND_REQUEST_ERROR_INVALID_ACCELERATION = 4;
    // Attempted to use velocity value outside of 0-60.
    COMMAND_REQUEST_ERROR_INVALID_VELOCITY = 5;
    // Using invalid direction for the command.
    COMMAND_REQUEST_ERROR_INVALID_DIRECTION = 6;
    // Attempted to send a carrier to a location outside of the configured line.
    COMMAND_REQUEST_ERROR_INVALID_LOCATION = 7;
    // Attempted to send a carrier exceeding the location range of the
    // configured line.
    COMMAND_REQUEST_ERROR_INVALID_DISTANCE = 8;
    // Attempted to send a command to carrier outside of 1-2048.
    COMMAND_REQUEST_ERROR_INVALID_CARRIER = 9;
    // A command missing the required parameter.
    COMMAND_REQUEST_ERROR_MISSING_PARAMETER = 10;
    // Attempted to remove or cancel a non-existing command.
    COMMAND_REQUEST_ERROR_COMMAND_NOT_FOUND = 11;
    // Attempted to send command to uninitialized carrier.
    COMMAND_REQUEST_ERROR_CARRIER_NOT_FOUND = 12;
    // Attempted to send a command when the CC Link connection is not
    // established.
    COMMAND_REQUEST_ERROR_CC_LINK_DISCONNECTED = 13;
    // Server unable to receive new command caused by out of memory.
    // Try `Command.Request.remove_command` to free the memory.
    COMMAND_REQUEST_ERROR_OUT_OF_MEMORY = 14;
    // Attempted to run more than 8 auto initialize instance.
    COMMAND_REQUEST_ERROR_MAXIMUM_AUTO_INITIALIZE_EXCEEDED = 15;
  }
}

// Response description to the command API.
message Response {
  oneof body {
    // Assigned ID for newly sent command.
    uint32 id = 1;
    // ID of cleared existing command.
    uint32 removed_id = 3;
    // Error during command's execution.
    Request.Error request_error = 2;
  }
}

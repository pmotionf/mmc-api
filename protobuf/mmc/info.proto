syntax = "proto3";
package mmc.info;

import "range.proto";

message Request {
  oneof body {
    // Command information request. Get current status of command; necessary
    // to determine if command is currently running, completed, or failed.
    Command command = 1;
    // Track information request. Get current track state information.
    Track track = 2;
  }
  // Request for status of specified command ID from the server. If no command
  // ID is provided, then request for status of all commands from the server.
  //
  // Expected response: `mmc.Response.body.info.body.commands`
  message Command {
    optional uint32 id = 1;
  }

  // Request track state information from server. One or more of the `info_`
  // flags must be enabled to select the kind of track information desired.
  // A filter may be optionally provided to limit the source of information
  // from the track.
  //
  // Expected response: `mmc.Response.body.info.body.track`
  message Track {
    // Line ID. Select line from which information will be retrieved.
    uint32 line = 1;

    // Retrieve driver state information.
    bool info_driver_state = 2;
    // Retrieve driver error information.
    bool info_driver_errors = 3;
    // Retrieve axis state information.
    bool info_axis_state = 4;
    // Retrieve axis errors information.
    bool info_axis_errors = 5;
    // Retrieve carrier state information.
    bool info_carrier_state = 6;

    // Filter information source if provided. Each filter is compatible with
    // every information flag.
    oneof filter {
      // Retrieve information from driver ID range. Driver information flags
      // will include drivers within this range. Axis information flags will
      // include every axis belonging to the drivers in this range. Carrier
      // information flags will include every carrier currently controlled by
      // one of the drivers in this range.
      Range drivers = 8;
      // Retrieve information from axis ID range. Driver information flags
      // will include drivers that contain one of the axes within this range.
      // Axis information flags will include axes within this range. Carrier
      // information flags will include every carrier currently controlled by
      // one of the axes in this range.
      Range axes = 9;
      // Retrieve information from carrier IDs. Driver information flags will
      // include drivers that control one of the carriers within this list.
      // Axis information flags will include axes that control one of the
      // carriers within this list. Carrier information flags will include
      // carriers within this list.
      Ids carriers = 10;
    }

    // List of IDs. At least one ID must be provided.
    message Ids {
      repeated uint32 ids = 1;
    }
  }

  enum Error {
    // This error code is unused, and will never be returned. It is reserved
    // as the default error code according to protobuf specification.
    INFO_REQUEST_ERROR_UNSPECIFIED = 0;
    // Invalid line ID provided. Ensure that line ID exists in track
    // configuration.
    INFO_REQUEST_ERROR_INVALID_LINE = 1;
    // Invalid axis ID provided. Ensure that axis ID exists in line.
    INFO_REQUEST_ERROR_INVALID_AXIS = 2;
    // Invalid driver ID provided. Ensure that driver ID exists in line.
    INFO_REQUEST_ERROR_INVALID_DRIVER = 3;
    // Request is missing a required parameter. Ensure that at least one of the
    // information flag is selected when requesting track information.
    INFO_REQUEST_ERROR_MISSING_PARAMETER = 4;
  }
}

message Response {
  oneof body {
    // Information for requested command(s). If empty, no matching command(s)
    // was found.
    Commands command = 1;
    // Information for requested track state.
    Track track = 2;
    // Info request error. This error field will be returned if the provided
    // info request could not be handled properly.
    Request.Error request_error = 3;
  }

  message Commands {
    repeated Command items = 1;
  }

  message Command {
    // Command ID. Valid IDs begin from 1, and may be reused after command
    // status is cleared from server history.
    uint32 id = 1;
    // Command status.
    Status status = 2;
    // Command error response, only if the status is `COMMAND_STATUS_FAILED`.
    optional Error error = 3;

    enum Status {
      // This command status is unused, and will never be returned. It is
      // reserved as the default status code according to protobuf
      // specification.
      COMMAND_STATUS_UNSPECIFIED = 0;
      // Command currently executing.
      COMMAND_STATUS_PROGRESSING = 1;
      // Command completed.
      COMMAND_STATUS_COMPLETED = 2;
      // Command execution failed.
      COMMAND_STATUS_FAILED = 3;
    }

    enum Error {
      // This error code is unused, and will never be returned. It is reserved
      // as the default error code according to protobuf specification.
      COMMAND_ERROR_UNSPECIFIED = 0;
      // System state prevented successful command execution. Ensure that all
      // preconditions are met with track info request before sending command.
      COMMAND_ERROR_INVALID_SYSTEM_STATE = 1;
      // Deprecated. Check `COMMAND_REQUEST_ERROR_INVALID_CARRIER` on
      // `Command.Request.Error`.
      COMMAND_ERROR_INVALID_CARRIER_ID = 2 [deprecated = true];
      // Driver connection failed while command progressing.
      COMMAND_ERROR_DRIVER_DISCONNECTED = 3;
      // Unexpected command execution error. This is likely an implementation
      // bug; please contact PMF support for assistance.
      COMMAND_ERROR_UNEXPECTED = 4;
      // Target carrier is removed while command progressing.
      COMMAND_ERROR_CARRIER_NOT_FOUND = 5;
      // Attempted to initialize an initialized carrier.
      COMMAND_ERROR_CARRIER_ALREADY_INITIALIZED = 6;
      // Target driver is stopped while command progressing. Consider resume
      // the driver before sending further command.
      COMMAND_ERROR_DRIVER_STOPPED = 7;
      // Carrier targetting a location outside of the configured track.
      COMMAND_ERROR_INVALID_CARRIER_TARGET = 8;
      // Attempted to assign a new carrier with an ID that is already used by
      // other carrier on the same line
      COMMAND_ERROR_CONFLICTING_CARRIER_ID = 9;
    }
  }

  message Track {
    // Line ID.
    uint32 line = 1;
    // Driver state information list. Empty if request flag was disabled.
    repeated Driver.State driver_state = 2;
    // Driver error information list. Empty if request flag was disabled.
    repeated Driver.Error driver_errors = 3;
    // Axis state information list. Empty if request flag was disabled.
    repeated Axis.State axis_state = 4;
    // Axis error information list. Empty if request flag was disabled.
    repeated Axis.Error axis_errors = 5;
    // Carrier state information list. Empty if request flag was disabled.
    repeated Carrier.State carrier_state = 6;

    message Axis {
      message State {
        // Axis ID.
        uint32 id = 1;
        // Axis is currently controlling a carrier.
        bool motor_active = 2;
        // Axis is waiting to pull carrier.
        bool waiting_pull = 3;
        // Axis is waiting to push carrier.
        bool waiting_push = 4;
        // Carrier ID; non-zero if an initialized carrier is on the axis.
        uint32 carrier = 5;
        // Axis back hall alarm is active. Magnet is detected above back hall
        // sensor.
        bool hall_alarm_back = 6;
        // Axis front hall alarm is active. Magnet is detected above front
        // hall sensor.
        bool hall_alarm_front = 7;
      }

      message Error {
        // Axis ID.
        uint32 id = 1;
        // Motor overcurrent detected. Motor control released to prevent
        // damage.
        bool overcurrent = 2;
      }
    }

    message Driver {
      message State {
        // Driver ID.
        uint32 id = 1;
        // Connection status between driver and server.
        bool connected = 2;
        // Driver is currently executing a command.
        bool busy = 3;
        // Driver motor release activated. All driver motors are inactive.
        bool motor_disabled = 4;
        // Driver emergency stop activated.
        bool stopped = 5;
        // Driver pause activated.
        bool paused = 6;
      }

      message Error {
        // Driver ID.
        uint32 id = 1;
        // Control loop exceeded maximum loop time.
        bool control_loop_time_exceeded = 2;
        // Inverter is overheated.
        bool inverter_overheat = 3;
        // Driver voltage supply too low.
        bool undervoltage = 4;
        // Driver voltage supply too high.
        bool overvoltage = 5;
        // Communication error with previous driver in line.
        bool comm_error_prev = 6;
        // Communication error with next driver in line.
        bool comm_error_next = 7;
      }
    }

    message Carrier {
      message State {
        // Carrier ID. Will always be non-zero.
        uint32 id = 1;
        // Position of the carrier in line, in meters.
        float position = 2;
        // Carrier's primary axis ID.
        uint32 axis_main = 3;
        // Carrier's auxiliary axis ID, if carrier is on top of two axes.
        optional uint32 axis_auxiliary = 4;
        // Collision avoidance system (CAS) disabled.
        bool cas_disabled = 5;
        // Collision avoidance system (CAS) triggered. Carrier will
        // automatically resume movement when path is clear.
        bool cas_triggered = 6;
        // Carrier state.
        State state = 7;

        enum State {
          CARRIER_STATE_NONE = 0;
          // Carrier is currently operating for line calibration.
          CARRIER_STATE_CALIBRATING = 1;
          // Carrier has completed line calibration, and may now be used for
          // normal operation.
          CARRIER_STATE_CALIBRATE_COMPLETED = 2;
          // Carrier is currently moving towards target destination.
          CARRIER_STATE_MOVING = 3;
          // Carrier has arrived within threshold at target destination.
          CARRIER_STATE_MOVE_COMPLETED = 4;
          // Carrier is initializing. Must not be used until initialization is
          // completed.
          CARRIER_STATE_INITIALIZING = 5;
          // Carrier initialization completed. May now be used for normal
          // operation.
          CARRIER_STATE_INITIALIZE_COMPLETED = 6;
          // Carrier is being pushed by axis. Used to eject carrier from line.
          CARRIER_STATE_PUSHING = 7;
          // Carrier push completed by axis. This state is not observed when
          // carrier is ejected from line.
          CARRIER_STATE_PUSH_COMPLETED = 8;
          // Carrier is being pulled by axis. Must not be used until pull is
          // completed.
          CARRIER_STATE_PULLING = 9;
          // Carrier pull completed by axis. May now be used for normal
          // operation.
          CARRIER_STATE_PULL_COMPLETED = 10;
          // Overcurrent detected in carrier axis motor. Carrier movement has
          // been canceled.
          CARRIER_STATE_OVERCURRENT = 11;
        }
      }
    }
  }
}

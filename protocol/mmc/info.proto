syntax = "proto3";
package mmc.info;

/// API for requesting information from the PMF's MMC Server
message Request{
  /// Request for a command status from the server.
  /// Expected response: Info.Response.Command
  message Command{
    uint32 command_id = 1;
  }

  /// Request carrier status either from carrier ID or axis ID from the server.
  /// Expected response: Info.Response.Carrier
  message Carrier{
    uint32 line_id = 1;
    oneof param{
        uint32 carrier_id = 2;
        uint32 axis_id = 3;
    }
  }

  /// Request axis information of the specified range from the server.
  /// Expected response: Info.Response.Axes
  message Axis{
    uint32 line_id = 1;
    message Range {
      uint32 start_id = 1;
      uint32 end_id = 2;
    }
    Range range = 2;
  }

  /// Request station information of the specified range from the server.
  /// Expected response: Info.Response.Stations
  message Station{
    uint32 line_id = 1;
    message Range {
      uint32 start_id = 1;
      uint32 end_id = 2;
    }
    Range range = 2;
  }

  /// Available info from the server
  oneof body{
    /// Get command status
    Command command = 20;
    /// Get carrier information
    Carrier carrier = 22;
    /// Get axis information
    Axis axis = 26;
    /// Get station information
    Station station = 27;
  }
}

/// Response description to the request info API
message Response{
  /// Command information. `error_response` is returned if the status is FAILED.
  message Command{
    enum Status {
      STATUS_UNSPECIFIED = 0;
      STATUS_PROGRESSING = 1;
      STATUS_COMPLETED = 2;
      STATUS_FAILED = 3;
      STATUS_QUEUED = 4;
    }
    Status status = 1;
    enum ErrorKind{
      ERROR_KIND_UNSPECIFIED = 0;
      ERROR_KIND_INVALID_COMMAND = 1;
      ERROR_KIND_CARRIER_NOT_FOUND = 2;
      ERROR_KIND_HOMING_FAILED = 3;
      ERROR_KIND_INVALID_PARAMETER = 4;
      ERROR_KIND_INVALID_SYSTEM_STATE = 5;
      ERROR_KIND_CARRIER_ALREADY_EXISTS = 6;
      ERROR_KIND_INVALID_AXIS = 7;
    }
    optional ErrorKind error_response = 2;
  }

  /// Axis information, returned in the form of line ID and array of axis
  message Axes{
    message Axis {
      message HallAlarm{
        bool front = 1;
        bool back = 2;
      }
      HallAlarm hall_alarm = 1;
      bool motor_enabled = 2;
      bool waiting_pull = 3;
      bool waiting_push = 4;
      bool overcurrent = 5;
      uint32 carrier_id = 6;
      /// Axis ID
      uint32 id = 7;
    }
    uint32 line_id = 1;
    repeated Axis axes = 2;
  }

  /// Station information, returned in the form of line ID and array of station
  message Stations{
    message Station{
      bool connected = 1;
      bool available = 2;
      bool servo_enabled = 3;
      bool stopped = 4;
      bool paused = 5;
      message StationError{
        bool control_loop_time_exceeded = 1;
        message PowerError{
          bool overvoltage = 1;
          bool undervoltage = 2;
        }
        PowerError power_error = 2;
        bool inverter_overheat = 3;
        message CommError{
          bool from_prev = 1;
          bool from_next = 2;
        }
        CommError communication_error = 4;
      }
      StationError errors = 6;
      /// Station ID
      uint32 id = 7;
    }
    uint32 line_id = 1;
    repeated Station stations = 2;
  }

  /// Carrier information
  message Carrier{
    uint32 main_axis_id = 1;
    uint32 aux_axis_id = 2;
    uint32 line_id = 4;
    float location = 5;
    uint32 id = 6;
    State state = 7;
    bool is_cas_triggered = 8;

    enum State{
      CARRIER_STATE_NONE = 0;

      CARRIER_STATE_WARMUP_PROGRESSING = 1;
      CARRIER_STATE_WARMUP_COMPLETED = 2;

      CARRIER_STATE_POS_MOVE_PROGRESSING = 3;
      CARRIER_STATE_POS_MOVE_COMPLETED = 4;
      CARRIER_STATE_SPD_MOVE_PROGRESSING = 5;
      CARRIER_STATE_SPD_MOVE_COMPLETED = 6;
      CARRIER_STATE_AUXILIARY = 7;
      CARRIER_STATE_AUXILIARY_COMPLETED = 8;

      CARRIER_STATE_FORWARD_CALIBRATION_PROGRESSING = 9;
      CARRIER_STATE_FORWARD_CALIBRATION_COMPLETED = 10;
      CARRIER_STATE_BACKWARD_CALIBRATION_PROGRESSING = 11;
      CARRIER_STATE_BACKWARD_CALIBRATION_COMPLETED = 12;

      CARRIER_STATE_FORWARD_ISOLATION_PROGRESSING = 13;
      CARRIER_STATE_FORWARD_ISOLATION_COMPLETED = 14;
      CARRIER_STATE_BACKWARD_ISOLATION_PROGRESSING = 15;
      CARRIER_STATE_BACKWARD_ISOLATION_COMPLETED = 16;
      CARRIER_STATE_FORWARD_RESTART_PROGRESSING = 17;
      CARRIER_STATE_FORWARD_RESTART_COMPLETED = 18;
      CARRIER_STATE_BACKWARD_RESTART_PROGRESSING = 19;
      CARRIER_STATE_BACKWARD_RESTART_COMPLETED = 20;

      CARRIER_STATE_PULL_FORWARD = 21;
      CARRIER_STATE_PULL_FORWARD_COMPLETED = 22;
      CARRIER_STATE_PULL_BACKWARD = 23;
      CARRIER_STATE_PULL_BACKWARD_COMPLETED = 24;
      CARRIER_STATE_PUSH = 25;
      CARRIER_STATE_PUSH_COMPLETED = 26;

      CARRIER_STATE_OVERCURRENT = 27;
    }
  }

  /// Error kind description
  enum RequestErrorKind {
    INFO_REQUEST_ERROR_UNSPECIFIED = 0;
    INFO_REQUEST_ERROR_INVALID_LINE = 1;
    INFO_REQUEST_ERROR_INVALID_AXIS = 2;
    INFO_REQUEST_ERROR_INVALID_STATION = 3;
    INFO_REQUEST_ERROR_CARRIER_NOT_FOUND = 4;
    INFO_REQUEST_ERROR_CC_LINK_DISCONNECTED = 5;
    INFO_REQUEST_ERROR_MISSING_PARAMETER = 6;
  }

  oneof body{
    /// Command information response
    Command command = 1;
    /// Carrier information response
    Carrier carrier = 3;
    /// Axis information response
    Axes axis = 4;
    /// Station information response
    Stations station = 5;
    /// Error kind if this response's request was invalid.
    RequestErrorKind request_error = 6;
  }
}

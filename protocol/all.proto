syntax = "proto3";
package mmc;

enum Direction{
    DIRECTION_UNSPECIFIED = 0;
    BACKWARD = 1;
    FORWARD = 2;
}

enum MessageType{
    MESSAGE_TYPE_UNSPECIFIED = 0;
    SEND_COMMAND = 1;
    LINE_CONFIG = 2;
    SERVER_VERSION = 3;
    HALL_STATUS = 4;
    CARRIER_STATUS = 5;
    COMMAND_STATUS = 6;
    REGISTER_X = 7;
    REGISTER_Y = 8;
    REGISTER_WW = 9;
    REGISTER_WR = 10;
    SYSTEM_ERROR = 11;
    MOVE_CARRIER = 12;
    PUSH_CARRIER = 13;
}

message SendCommand{
    message GetX{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message GetY{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message GetWr{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message GetWw{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message ReleaseAxisServo{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message StopPullCarrier{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message StopPushCarrier{
        int32 line_idx = 1;
        int32 axis_idx = 2;
    }

    message ClearErrors{
        int32 line_idx = 1;
        optional int32 axis_idx = 2;
    }

    message ClearCarrierInfo{
        int32 line_idx = 1;
        optional int32 axis_idx = 2;
    }

    message GetStatus{
        message Carrier{
            int32 line_idx = 1;
            optional int32 axis_idx = 2;
            optional int32 carrier_id = 3;
        }
        message Hall{
            int32 line_idx = 1;
            optional int32 axis_idx = 2;
        }
        message Command{
            int32 line_idx = 1;
        }
        oneof status_kind{
            Carrier carrier = 1;
            Hall hall = 2;
            Command command = 3;
        }
    }

    message NoParam {}

    message SetCommand{
        RegisterWw.CommandCode command_code = 1;
        int32 line_idx = 2;
        optional int32 axis_idx = 3;
        optional int32 carrier_id = 4;
        optional float location_distance = 5;
        optional int32 speed = 6;
        optional int32 acceleration = 7;
        optional Direction link_axis = 8;
        optional Direction use_sensor = 9;
    }

    message AutoInitialize{
        optional int32 line_id = 1;
    }

    message MoveCarrier{
        int32 line_idx = 1;
        int32 carrier_id = 2;
        oneof target{
            int32 axis_id = 3;
            float location_distance = 4;
        }
    }

    message PushCarrier{
        int32 line_idx = 1;
        int32 carrier_id = 2;
        Direction direction = 3;
        optional int32 axis_idx = 4;
    }

    message PullCarrier{
        int32 line_idx = 1;
        int32 axis_idx = 2;
        int32 carrier_id = 3;
        Direction direction = 4;
        optional float destination = 5;
    }

    message IsolateCarrier{
        int32 line_idx = 1;
        int32 axis_idx = 2;
        int32 carrier_id = 3;
        Direction direction = 4;
        Direction link_axis = 5;
    }

    MessageType message_type = 1;

    oneof command_kind{
        GetX get_x = 2;
        GetY get_y = 3;
        GetWr get_wr = 4;
        GetWw get_ww = 5;
        GetStatus get_status = 6;
        NoParam get_version = 7;
        ClearErrors clear_errors = 8;
        ClearCarrierInfo clear_carrier_info = 9;
        NoParam reset_mcl = 10;
        ReleaseAxisServo release_axis_servo = 11;
        SetCommand set_command = 12;
        StopPullCarrier stop_pull_carrier = 13;
        AutoInitialize auto_initialize = 14;
        StopPushCarrier stop_push_carrier = 15;
        MoveCarrier move_carrier = 16;
        PushCarrier push_carrier = 17;
        PullCarrier pull_carrier = 18;
        IsolateCarrier isolate_carrier = 19;
    }
}

message LineConfig{
    message LineConfiguration{
        message Range{
            enum Channel{
                CHANNEL_UNSPECIFIED = 0;
                CC_LINK_1SLOT = 1;
                CC_LINK_2SLOT = 2;
                CC_LINK_3SLOT = 3;
                CC_LINK_4SLOT = 4;
            }
            Channel channel = 1;
            int32 start = 2;
            int32 end = 3;
        }
        int32 axes = 1;
        repeated Range ranges = 2;
    }
    MessageType message_type = 1;
    repeated LineConfiguration lines = 2;
    repeated string line_names = 3;
}

message ServerVersion{
    MessageType message_type = 1;
    int32 major = 2;
    int32 minor = 3;
    int32 patch = 4;
}

message HallStatus{
    MessageType message_type = 1;
    bool front = 2;
    bool back = 3;
}

message CarrierStatus{
    message AxisIndices{
        int32 main_axis = 1;
        int32 aux_axis = 2;
    }
    MessageType message_type = 1;
    int32 id = 2;
    AxisIndices axis_idx = 3;
    float location = 4;
    RegisterWr.Carrier.CarrierDescription.State state = 5;        
}

message CommandStatus{
    MessageType message_type = 1;
    bool received = 2;
    RegisterWr.CommandResponse response = 3;
}

message RegisterX{
    MessageType message_type = 1;
    bool cc_link_enabled = 2;
    bool command_ready = 3;
    bool command_received = 4;
    bool axis_cleared_carrier = 5;
    bool cleared_carrier = 6;
    bool servo_enabled = 7;
    bool emergency_stop_enabled = 8;
    bool paused = 9;
    message MotorEnabled{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    MotorEnabled motor_enabled = 10;
    bool vdc_undervoltage_detected = 11;
    bool vdc_overvoltage_detected = 12;
    bool errors_cleared = 13;
    message CommunicationError{
        bool from_prev = 1;
        bool from_next = 2;
    }
    CommunicationError communication_error = 14;
    bool inverter_overheat_detected = 15;
    message OvercurrentDetected{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    OvercurrentDetected overcurrent_detected = 16;
    message HallAlarm{
        message Side{
            bool back = 1;
            bool front = 2;
        }
        Side axis1 = 1;
        Side axis2 = 2;
        Side axis3 = 3;
    }
    HallAlarm hall_alarm = 17;
    message WaitPullCarrier{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    WaitPullCarrier wait_pull_carrier = 18;
    message WaitPushCarrier{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    WaitPushCarrier wait_push_carrier = 19;
    bool control_loop_max_time_exceeded = 20;
    bool initial_data_processing_request = 21;
    bool initial_data_setting_complete = 22;
    bool error_status = 23;
    bool remote_ready = 24;
}

message RegisterY{
    MessageType message_type = 1;
    bool cc_link_enable = 2;
    bool start_command = 3;
    bool reset_command_received = 4;
    bool axis_clear_carrier = 5;
    bool clear_carrier = 6;
    bool axis_servo_release = 7;
    bool servo_release = 8;
    bool emergency_stop = 9;
    bool temporary_pause = 10;
    bool clear_errors = 11;
    message ResetPullCarrier{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    ResetPullCarrier reset_pull_carrier = 12;
    message ResetPushCarrier{
        bool axis1 = 1;
        bool axis2 = 2;
        bool axis3 = 3;
    }
    ResetPushCarrier reset_push_carrier = 13;

}

message RegisterWw{
    MessageType message_type = 1;
    enum CommandCode{
        COMMAND_CODE_UNSPECIFIED = 0;
        NONE = 1;
        SET_LINE_ZERO = 2;
        // "By Position" commands calculate carrier movement by constant hall
        // sensor position feedback, and is much more precise in destination.
        POSITION_MOVE_CARRIER_AXIS = 3;
        POSITION_MOVE_CARRIER_LOCATION = 4;
        POSITION_MOVE_CARRIER_DISTANCE = 5;
        // "By Speed" commands calculate carrier movement by constant hall
        // sensor speed feedback. It should mostly not be used, as the
        // destination position becomes far too imprecise. However, it is
        // meant to maintain a certain speed while the carrier is traveling,
        // and to avoid the requirement of having a known system position.
        SPEED_MOVE_CARRIER_AXIS = 6;
        SPEED_MOVE_CARRIER_LOCATION = 7;
        SPEED_MOVE_CARRIER_DISTANCE = 8;
        ISOLATE_FORWARD = 9;
        ISOLATE_BACKWARD = 10;
        CALIBRATION = 11;
        SET_CARRIER_ID_AT_AXIS = 12;
        PUSH_FORWARD = 13;
        PUSH_BACKWARD = 14;
        PULL_FORWARD = 15;
        PULL_BACKWARD = 16;
        PUSH_TRANSITION_FORWARD = 17;
        PUSH_TRANSITION_BACKWARD = 18;
        PULL_TRANSITION_AXIS_FORWARD = 19;
        PULL_TRANSITION_AXIS_BACKWARD = 20;
        PULL_TRANSITION_LOCATION_FORWARD = 21;
        PULL_TRANSITION_LOCATION_BACKWARD = 22;
    }
    CommandCode command = 2;
    int32 axis = 3;
    message Carrier{
        oneof target{
            float f32 = 1;
            int32 u32 = 2;
            sint32 i32 = 3;
        }
        int32 id = 4;
        bool enable_cas = 5;
        bool isolate_link_prev_axis = 6;
        bool isolate_link_next_axis = 7;
        int32 speed = 8;
        int32 acceleration = 9;
    }
    Carrier carrier = 4;
}

message RegisterWr{
    MessageType message_type = 1;
    enum CommandResponse{
        COMMAND_RESPONSE_UNSPECIFIED = 0;
        NO_ERROR = 1;
        INVALID_COMMAND = 2;
        CARRIER_NOT_FOUND = 3;
        HOMING_FAILED = 4;
        INVALID_PARAMETER = 5;
        INVALID_SYSTEM_STATE = 6;
        CARRIER_ALREADY_EXISTS = 7;
        INVALID_AXIS = 8;
    }
    CommandResponse command_response = 2;
    message CommunicationReceived{
        int32 id = 1;
        enum DriverMessageKind{
            DRIVER_MESSAGE_KIND_UNSPECIFIED = 0;
            NONE = 1;
            UPDATE = 2;
            PROF_REQ = 3;
            PROF_NOTI = 4;
            UPDATE_CALI_HOME = 5;
            UPDATE_MECH_ANGLE_OFFSET = 6;
            ON_POS_REQ = 7;
            ON_POS_RSP = 8;
            OFF_POS_REQ = 9;
            OFF_POS_RSP = 10;
            CLEAR_CARRIER_INFO = 11;
        }
        DriverMessageKind kind = 2;
        bool failed_bcc = 3;
    }
    CommunicationReceived received_backward = 3;
    CommunicationReceived received_forward = 4;
    message Carrier{
        message CarrierDescription{
            float location = 1;
            int32 id = 2;
            bool arrived = 3;
            bool auxiliary = 4;
            bool enabled = 5;
            bool quasi = 6;
            message CAS{
                bool enabled = 1;
                bool triggered = 2;
            }
            CAS cas = 7;
            enum State{
                STATE_UNSPECIFIED = 0;
                NONE = 1;

                WARMUP_PROGRESSING = 2;
                WARMUP_COMPLETED = 3;

                POS_MOVE_PROGRESSING = 4;
                POS_MOVE_COMPLETED = 5;
                SPD_MOVE_PROGRESSING = 6;
                SPD_MOVE_COMPLETED = 7;
                AUXILIARY = 8;
                AUXILIARY_COMPLETED = 9;

                FORWARD_CALIBRATION_PROGRESSING = 10;
                FORWARD_CALIBRATION_COMPLETED = 11;
                BACKWARD_CALIBRATION_PROGRESSING = 12;
                BACKWARD_CALIBRATION_COMPLETED = 13;

                FORWARD_ISOLATION_PROGRESSING = 14;
                FORWARD_ISOLATION_COMPLETED = 15;
                BACKWARD_ISOLATION_PROGRESSING = 16;
                BACKWARD_ISOLATION_COMPLETED = 17;
                FORWARD_RESTART_PROGRESSING = 18;
                FORWARD_RESTART_COMPLETED = 19;
                BACKWARD_RESTART_PROGRESSING = 20;
                BACKWARD_RESTART_COMPLETED = 21;

                PULL_FORWARD = 22;
                PULL_FORWARD_COMPLETED = 23;
                PULL_BACKWARD = 24;
                PULL_BACKWARD_COMPLETED = 25;
                PUSH = 26;
                PUSH_COMPLETED = 27;

                OVERCURRENT = 28;
            }
            State state = 8;
        }
        CarrierDescription axis1 = 1;
        CarrierDescription axis2 = 2;
        CarrierDescription axis3 = 3;
    }
    Carrier carrier = 5;

}

message SystemError{
    MessageType message_type = 1;
    enum ErrorType{
        ERROR_UNSPECIFIED = 0;
        CC_LINK_DISCONNECTED = 1;
        VDC_UNDERVOLTAGE_DETECTED = 2;
        VDC_OVERVOLTAGE_DETECTED = 3;
        COMMUNICATION_ERROR_DETECTED = 4;
        INVERTER_OVERHEAT_DETECTED = 5;
        OVERCURRENT_DETECTED = 6;
        CONTROL_LOOP_MAX_TIME_EXCEEDED = 7;
    }
    message ErrorLocation{
        ErrorType error_type = 1;
        int32 axis_idx = 2;
    }
    repeated ErrorLocation errors = 2;
}